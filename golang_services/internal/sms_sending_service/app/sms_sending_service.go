package app

import (
	"context"
	// "encoding/json" // Not used directly here, but in main.go for NATS payload
	"errors"
	"fmt"
	"log/slog"
	"time"
    "database/sql" // For sql.NullTime


	"github.com/aradsms/golang_services/api/proto/billingservice" // Billing service proto
	"github.com/aradsms/golang_services/internal/core_domain"
	"github.com/aradsms/golang_services/internal/sms_sending_service/adapters/grpc_clients" // Billing client
	"github.com/aradsms/golang_services/internal/sms_sending_service/adapters/smsprovider"
	"github.com/aradsms/golang_services/internal/sms_sending_service/repository"
	"github.com/google/uuid"
)

// NATSMessagePayload defines the expected structure from the NATS "send.sms" topic.
type NATSMessagePayload struct {
	UserID      string `json:"user_id"`
	SenderID    string `json:"sender_id"`
	Recipient   string `json:"recipient"`
	Content     string `json:"content"`
	MessageID   string `json:"message_id,omitempty"` // Optional: ID generated by public-api, or generate here
	UserData    *string `json:"user_data,omitempty"`
    Segments    int    `json:"segments,omitempty"` // Optional: can be calculated here
}

// SMSSendingService provides core logic for sending SMS.
type SMSSendingService struct {
	outboxRepo    repository.OutboxMessageRepository
	provider      smsprovider.Adapter // For Phase 2, one provider. Later, a map or router.
	billingClient *grpc_clients.BillingServiceClient
	logger        *slog.Logger
}

// NewSMSSendingService creates a new SMSSendingService.
func NewSMSSendingService(
	outboxRepo repository.OutboxMessageRepository,
	provider smsprovider.Adapter,
	billingClient *grpc_clients.BillingServiceClient,
	logger *slog.Logger,
) *SMSSendingService {
	return &SMSSendingService{
		outboxRepo:    outboxRepo,
		provider:      provider,
		billingClient: billingClient,
		logger:        logger.With("service", "sms_sending"),
	}
}

// ProcessSendSMSJob handles a new SMS send request.
func (s *SMSSendingService) ProcessSendSMSJob(ctx context.Context, payload NATSMessagePayload) error {
	l := s.logger.With("recipient", payload.Recipient, "userID", payload.UserID)
	l.InfoContext(ctx, "Processing send SMS job")

	messageID := payload.MessageID
	if messageID == "" {
		messageID = uuid.NewString() // Generate a new ID if not provided
	}

    // 1. Create OutboxMessage with 'queued' or 'processing' status
    // For simplicity, let's assume segments are calculated by frontend or a previous step.
    // If not, calculate segments here based on payload.Content.
    segments := payload.Segments
    if segments == 0 {
        // Basic segment calculation (very simplified)
        if len(payload.Content) > 160 { // Assuming GSM-7, no unicode
            segments = (len(payload.Content) + 152) / 153 // 160 - 7 for UDH
        } else {
            segments = 1
        }
    }

    now := time.Now().UTC()
	outboxMsg := &core_domain.OutboxMessage{
		ID:        messageID,
		UserID:    payload.UserID,
		SenderID:  payload.SenderID,
		Recipient: payload.Recipient,
		Content:   payload.Content,
		Status:    core_domain.StatusProcessing, // Mark as processing immediately
		Segments:  segments,
		UserData:  payload.UserData,
		CreatedAt: now,
		UpdatedAt: now,
        ProcessedAt: &now,
	}

	_, err := s.outboxRepo.Create(ctx, outboxMsg)
	if err != nil {
		l.ErrorContext(ctx, "Failed to create initial outbox message", "error", err, "messageID", messageID)
		return fmt.Errorf("failed to store initial message: %w", err)
	}
	l = l.With("messageID", messageID)


    // 2. Check and Deduct Credit via Billing Service
    amountToDeduct := float64(outboxMsg.Segments) * 0.05 // Example cost

    billingReq := &billingservice.CheckAndDeductCreditRequest{
        UserId:           payload.UserID,
        AmountToDeduct:   amountToDeduct,
        TransactionType:  billingservice.TransactionTypeProto_TRANSACTION_TYPE_PROTO_SMS_CHARGE,
        Description:      fmt.Sprintf("SMS charge for message to %s (ID: %s)", payload.Recipient, messageID),
        RelatedMessageId: messageID,
    }
    _, err = s.billingClient.CheckAndDeductCredit(ctx, billingReq)
    if err != nil {
        l.ErrorContext(ctx, "Credit check/deduction failed via billing service", "error", err)
        errMsg := fmt.Sprintf("Billing error: %v", err)
        // Using a nil time.Time for sentAt as it wasn't sent
        if updateErr := s.outboxRepo.UpdateStatus(ctx, messageID, core_domain.StatusFailedToSend, nil, nil, &errMsg, nil); updateErr != nil {
            l.ErrorContext(ctx, "Additionally failed to update status to FailedToSend after billing error", "updateError", updateErr)
        }
        return fmt.Errorf("billing failed: %w", err)
    }
    l.InfoContext(ctx, "Credit check/deduction successful")

    // 3. Send via Provider Adapter
    providerReq := smsprovider.SMSRequestData{
        InternalMessageID: messageID,
        SenderID:          payload.SenderID,
        Recipient:         payload.Recipient,
        Content:           payload.Content,
    }
    sendResponse, providerErr := s.provider.Send(ctx, providerReq)
    sentAt := time.Now().UTC() // Record time immediately after send attempt

    if providerErr != nil { // Network error or critical error from provider adapter itself
        l.ErrorContext(ctx, "Failed to send SMS via provider adapter (critical error)", "error", providerErr, "provider", s.provider.GetName())
        errMsg := fmt.Sprintf("Provider sending error: %v", providerErr)
        if err := s.outboxRepo.UpdateStatus(ctx, messageID, core_domain.StatusFailedToSend, nil, nil, &errMsg, &sentAt); err != nil {
             l.ErrorContext(ctx, "Additionally failed to update status to FailedToSend after provider critical error", "updateError", err)
        }
        return fmt.Errorf("provider send error: %w", providerErr)
    }

    // 4. Update OutboxMessage with provider's response
    if sendResponse.Success {
        l.InfoContext(ctx, "SMS submitted successfully to provider", "provider_msg_id", sendResponse.ProviderMessageID, "provider", s.provider.GetName())
        err = s.outboxRepo.UpdateStatus(ctx, messageID, core_domain.StatusSent, &sendResponse.ProviderMessageID, strPtr(fmt.Sprintf("%d", sendResponse.StatusCode)), nil, &sentAt)
    } else {
        l.WarnContext(ctx, "SMS submission failed by provider", "error_msg", sendResponse.ErrorMessage, "status_code", sendResponse.StatusCode, "provider", s.provider.GetName())
        err = s.outboxRepo.UpdateStatus(ctx, messageID, core_domain.StatusFailedToSend, nil, strPtr(fmt.Sprintf("%d", sendResponse.StatusCode)), &sendResponse.ErrorMessage, &sentAt)
    }

    if err != nil {
        l.ErrorContext(ctx, "Failed to update final outbox message status", "error", err)
        return fmt.Errorf("failed to update message status: %w", err)
    }

	l.InfoContext(ctx, "SMS job processing completed")
	return nil
}

// Helper for string pointers
func strPtr(s string) *string { return &s }

// sqlNullTime is a helper for converting time.Time to *time.Time / sql.NullTime
// This is not needed if ProcessedAt is *time.Time in domain model
func sqlNullTime(t time.Time) sql.NullTime {
    return sql.NullTime{Time: t, Valid: !t.IsZero()}
}
