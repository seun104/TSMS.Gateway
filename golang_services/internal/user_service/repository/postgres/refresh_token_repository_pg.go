package postgres

import (
	"context"
    "errors"
	"github.com/aradsms/golang_services/internal/user_service/domain"
	"github.com/aradsms/golang_services/internal/user_service/repository"
	"github.com/jackc/pgx/v5/pgxpool"
    "github.com/jackc/pgx/v5" // For pgx.ErrNoRows
    "github.com/google/uuid"
    "time"
)

var ErrRefreshTokenNotFound = errors.New("refresh token not found")
var ErrDuplicateRefreshToken = errors.New("duplicate refresh token") // If ID needs to be unique on insert

type pgRefreshTokenRepository struct {
	db *pgxpool.Pool
}

func NewPgRefreshTokenRepository(db *pgxpool.Pool) repository.RefreshTokenRepository {
	return &pgRefreshTokenRepository{db: db}
}

func (r *pgRefreshTokenRepository) Create(ctx context.Context, token *domain.RefreshToken) error {
    // Assuming token.ID is pre-filled (e.g., JWT's JTI)
    // If token.ID is to be generated by DB (e.g. serial or gen_random_uuid()), then it needs to be returned.
    // For now, assume ID is set by application.
    token.CreatedAt = time.Now() // Ensure CreatedAt is set
    query := `INSERT INTO refresh_tokens (id, user_id, token_hash, expires_at, created_at)
              VALUES ($1, $2, $3, $4, $5)`
    _, err := r.db.Exec(ctx, query, token.ID, token.UserID, token.TokenHash, token.ExpiresAt, token.CreatedAt)
    // Add duplicate key error handling if token.ID or token.TokenHash has unique constraint
    // var pgErr *pgconn.PgError
    // if errors.As(err, &pgErr) && pgErr.Code == "23505" {
    // 	return ErrDuplicateRefreshToken
    // }
    return err
}

func (r *pgRefreshTokenRepository) GetByID(ctx context.Context, id string) (*domain.RefreshToken, error) {
    token := &domain.RefreshToken{}
    query := `SELECT id, user_id, token_hash, expires_at, created_at
              FROM refresh_tokens WHERE id = $1`
    err := r.db.QueryRow(ctx, query, id).Scan(
        &token.ID, &token.UserID, &token.TokenHash, &token.ExpiresAt, &token.CreatedAt,
    )
    if err != nil {
        if errors.Is(err, pgx.ErrNoRows) {
            return nil, ErrRefreshTokenNotFound
        }
        return nil, err
    }
    return token, nil
}


func (r *pgRefreshTokenRepository) GetByTokenHash(ctx context.Context, tokenHash string) (*domain.RefreshToken, error) {
    token := &domain.RefreshToken{}
    query := `SELECT id, user_id, token_hash, expires_at, created_at
              FROM refresh_tokens WHERE token_hash = $1`
    err := r.db.QueryRow(ctx, query, tokenHash).Scan(
        &token.ID, &token.UserID, &token.TokenHash, &token.ExpiresAt, &token.CreatedAt,
    )
    if err != nil {
        if errors.Is(err, pgx.ErrNoRows) {
            return nil, ErrRefreshTokenNotFound
        }
        return nil, err
    }
    return token, nil
}

func (r *pgRefreshTokenRepository) Delete(ctx context.Context, id string) error {
    query := "DELETE FROM refresh_tokens WHERE id = $1"
    _, err := r.db.Exec(ctx, query, id)
    return err
}

func (r *pgRefreshTokenRepository) DeleteByUserID(ctx context.Context, userID string) error {
    query := "DELETE FROM refresh_tokens WHERE user_id = $1"
    _, err := r.db.Exec(ctx, query, userID)
    return err
}
