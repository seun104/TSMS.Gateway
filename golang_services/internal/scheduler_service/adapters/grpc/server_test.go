package grpc

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"io"
	"log/slog"
	"testing"
	"time"

	"github.com/AradIT/aradsms/golang_services/api/proto/schedulerservice"
	pb "github.com/AradIT/aradsms/golang_services/api/proto/schedulerservice"
	"github.com/AradIT/aradsms/golang_services/internal/scheduler_service/domain"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/emptypb"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// --- Mocks ---

type MockScheduledJobRepository struct {
	mock.Mock
}

func (m *MockScheduledJobRepository) CreateJob(ctx context.Context, job *domain.ScheduledJob) error {
	args := m.Called(ctx, job)
	return args.Error(0)
}

func (m *MockScheduledJobRepository) GetJob(ctx context.Context, jobID uuid.UUID) (*domain.ScheduledJob, error) {
	args := m.Called(ctx, jobID)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*domain.ScheduledJob), args.Error(1)
}

func (m *MockScheduledJobRepository) UpdateJob(ctx context.Context, job *domain.ScheduledJob) error {
	args := m.Called(ctx, job)
	return args.Error(0)
}

func (m *MockScheduledJobRepository) DeleteJob(ctx context.Context, jobID uuid.UUID) error {
	args := m.Called(ctx, jobID)
	return args.Error(0)
}

func (m *MockScheduledJobRepository) ListJobs(ctx context.Context, userID uuid.NullUUID, jobType domain.JobType, status domain.JobStatus, page, pageSize int) ([]*domain.ScheduledJob, int, error) {
	args := m.Called(ctx, userID, jobType, status, page, pageSize)
	if args.Get(0) == nil {
		return nil, args.Int(1), args.Error(2)
	}
	return args.Get(0).([]*domain.ScheduledJob), args.Int(1), args.Error(2)
}

// AcquireDueJobs is part of the interface but not directly used by gRPC handlers, more by poller.
// Adding it for completeness of the mock if other parts of the app package use it via this interface.
func (m *MockScheduledJobRepository) AcquireDueJobs(ctx context.Context, dueTime time.Time, limit int) ([]*domain.ScheduledJob, error) {
	args := m.Called(ctx, dueTime, limit)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).([]*domain.ScheduledJob), args.Error(1)
}

func (m *MockScheduledJobRepository) UpdateStatus(ctx context.Context, jobID uuid.UUID, status domain.JobStatus, processedAt time.Time, processingErr sql.NullString, retryCount int) error {
	args := m.Called(ctx, jobID, status, processedAt, processingErr, retryCount)
	return args.Error(0)
}

func (m *MockScheduledJobRepository) MarkForRetry(ctx context.Context, jobID uuid.UUID, nextRunAt time.Time, retryCount int, lastError sql.NullString) error {
	args := m.Called(ctx, jobID, nextRunAt, retryCount, lastError)
	return args.Error(0)
}

// --- Test Setup ---

type schedulerServerTestComponents struct {
	server   *SchedulerServer
	mockRepo *MockScheduledJobRepository
	logger   *slog.Logger
}

func setupSchedulerServerTest(t *testing.T) schedulerServerTestComponents {
	logger := slog.New(slog.NewTextHandler(io.Discard, nil))
	mockRepo := new(MockScheduledJobRepository)

	server := NewSchedulerServer(mockRepo, logger)

	return schedulerServerTestComponents{
		server:   server,
		mockRepo: mockRepo,
		logger:   logger,
	}
}

// --- Tests ---

func TestSchedulerServer_CreateScheduledJob(t *testing.T) {
	comps := setupSchedulerServerTest(t)
	ctx := context.Background()
	userID := uuid.New()
	payload := json.RawMessage(`{"message": "test"}`)

	req := &pb.CreateScheduledJobRequest{
		UserId:    userID.String(),
		JobType:   string(domain.JobTypeSMS),
		Payload:   string(payload),
		RunAt:     timestamppb.New(time.Now().Add(1 * time.Hour)),
		Priority:  1,
		UniqueKey: uuid.New().String(),
	}

	t.Run("SuccessfulCreation", func(t *testing.T) {
		comps.mockRepo.On("CreateJob", ctx, mock.AnythingOfType("*domain.ScheduledJob")).Return(nil).Once()

		res, err := comps.server.CreateScheduledJob(ctx, req)

		require.NoError(t, err)
		require.NotNil(t, res)
		assert.NotEmpty(t, res.JobId) // JobId should be generated by the server/handler

		// Verify that the ID in the response can be parsed as UUID
		_, parseErr := uuid.Parse(res.JobId)
		assert.NoError(t, parseErr, "JobId in response should be a valid UUID")

		comps.mockRepo.AssertCalled(t, "CreateJob", ctx, mock.MatchedBy(func(job *domain.ScheduledJob) bool {
			return job.UserID.UUID == userID && job.UserID.Valid &&
				job.JobType == domain.JobTypeSMS &&
				string(job.Payload) == string(payload) &&
				job.Priority == 1 &&
				job.UniqueKey.String == req.UniqueKey && job.UniqueKey.Valid
		}))
		comps.mockRepo.AssertExpectations(t) // Ensure only expected calls were made
		// Reset mock for next sub-test if necessary, or ensure unique mock instances per sub-test
		comps.mockRepo.ExpectedCalls = nil // Reset for next sub-test manually if comps is reused
	})

	t.Run("RepositoryErrorOnCreation", func(t *testing.T) {
		dbError := errors.New("DB error")
		comps.mockRepo.On("CreateJob", ctx, mock.AnythingOfType("*domain.ScheduledJob")).Return(dbError).Once()

		res, err := comps.server.CreateScheduledJob(ctx, req)

		require.Error(t, err)
		assert.Nil(t, res)
		st, ok := status.FromError(err)
		require.True(t, ok)
		assert.Equal(t, codes.Internal, st.Code())
		assert.Contains(t, st.Message(), "failed to create scheduled job")

		comps.mockRepo.AssertExpectations(t)
		comps.mockRepo.ExpectedCalls = nil
	})

	t.Run("InvalidUserIDFormat", func(t *testing.T) {
		invalidReq := &pb.CreateScheduledJobRequest{
			UserId:    "not-a-uuid",
			JobType:   string(domain.JobTypeSMS),
			Payload:   string(payload),
			RunAt:     timestamppb.New(time.Now().Add(1 * time.Hour)),
		}
		// No mock repo call expected as validation should fail first

		res, err := comps.server.CreateScheduledJob(ctx, invalidReq)

		require.Error(t, err)
		assert.Nil(t, res)
		st, ok := status.FromError(err)
		require.True(t, ok)
		assert.Equal(t, codes.InvalidArgument, st.Code())
		assert.Contains(t, st.Message(), "user_id must be a valid UUID")
	})

	t.Run("InvalidRunAt", func(t *testing.T) {
		invalidReq := &pb.CreateScheduledJobRequest{
			UserId:    userID.String(),
			JobType:   string(domain.JobTypeSMS),
			Payload:   string(payload),
			RunAt:     &timestamppb.Timestamp{Seconds: -62135596801, Nanos: 0}, // Invalid (e.g. zero value before check)
		}
		// This test depends on how server validates RunAt. Protobuf default is 0-time.
		// Let's assume our server checks if RunAt is in the past or significantly off.
		// For now, a simple nil check or IsValid check on timestamppb.
		// The current handler logic doesn't explicitly reject past RunAt, but ToDomain might.
		// Let's assume a ToDomain conversion or validation step catches invalid timestamps.
		// If it doesn't, this test might need adjustment or the handler strengthened.
		// For now, assume that an invalid timestamp (e.g., if .IsValid() is false) is caught.
		// For this specific test, let's make RunAt nil to test that path.
		invalidReq.RunAt = nil

		res, err := comps.server.CreateScheduledJob(ctx, invalidReq)
		require.Error(t, err)
		st, ok := status.FromError(err)
		require.True(t, ok)
		assert.Equal(t, codes.InvalidArgument, st.Code())
		assert.Contains(t, st.Message(), "run_at is required")
	})
}


func TestSchedulerServer_GetScheduledJob(t *testing.T) {
	comps := setupSchedulerServerTest(t)
	ctx := context.Background()
	jobID := uuid.New()
	userID := uuid.New()
	payloadJSON := json.RawMessage(`{"key":"value"}`)

	req := &pb.GetScheduledJobRequest{JobId: jobID.String()}

	t.Run("SuccessfulGet", func(t *testing.T) {
		mockJob := &domain.ScheduledJob{
			ID:        jobID,
			UserID:    uuid.NullUUID{UUID: userID, Valid: true},
			JobType:   domain.JobTypeSMS,
			Payload:   payloadJSON,
			RunAt:     time.Now().Add(time.Hour),
			Status:    domain.StatusQueued,
			Priority:  1,
			UniqueKey: sql.NullString{String: "ukey", Valid: true},
			CreatedAt: time.Now().Add(-time.Minute),
			UpdatedAt: time.Now(),
		}
		comps.mockRepo.On("GetJob", ctx, jobID).Return(mockJob, nil).Once()

		res, err := comps.server.GetScheduledJob(ctx, req)

		require.NoError(t, err)
		require.NotNil(t, res)
		require.NotNil(t, res.Job)
		assert.Equal(t, jobID.String(), res.Job.JobId)
		assert.Equal(t, userID.String(), res.Job.UserId)
		assert.Equal(t, string(domain.JobTypeSMS), res.Job.JobType)
		assert.Equal(t, string(payloadJSON), res.Job.Payload)
		assert.Equal(t, string(domain.StatusQueued), res.Job.Status)

		comps.mockRepo.AssertExpectations(t)
		comps.mockRepo.ExpectedCalls = nil
	})

	t.Run("JobNotFound", func(t *testing.T) {
		comps.mockRepo.On("GetJob", ctx, jobID).Return(nil, domain.ErrScheduledJobNotFound).Once()

		res, err := comps.server.GetScheduledJob(ctx, req)

		require.Error(t, err)
		assert.Nil(t, res)
		st, ok := status.FromError(err)
		require.True(t, ok)
		assert.Equal(t, codes.NotFound, st.Code())

		comps.mockRepo.AssertExpectations(t)
		comps.mockRepo.ExpectedCalls = nil
	})

	t.Run("RepositoryErrorOnGet", func(t *testing.T) {
		dbError := errors.New("DB error")
		comps.mockRepo.On("GetJob", ctx, jobID).Return(nil, dbError).Once()

		res, err := comps.server.GetScheduledJob(ctx, req)

		require.Error(t, err)
		assert.Nil(t, res)
		st, ok := status.FromError(err)
		require.True(t, ok)
		assert.Equal(t, codes.Internal, st.Code())

		comps.mockRepo.AssertExpectations(t)
		comps.mockRepo.ExpectedCalls = nil
	})

	t.Run("InvalidJobIDFormat", func(t *testing.T) {
		invalidReq := &pb.GetScheduledJobRequest{JobId: "not-a-uuid"}
		res, err := comps.server.GetScheduledJob(ctx, invalidReq)

		require.Error(t, err)
		assert.Nil(t, res)
		st, ok := status.FromError(err)
		require.True(t, ok)
		assert.Equal(t, codes.InvalidArgument, st.Code())
		assert.Contains(t, st.Message(), "job_id must be a valid UUID")
	})
}

func TestSchedulerServer_UpdateScheduledJob(t *testing.T) {
	comps := setupSchedulerServerTest(t)
	ctx := context.Background()
	jobID := uuid.New()
	userID := uuid.New()
	newPayload := json.RawMessage(`{"key":"new_value"}`)
	newRunAt := time.Now().Add(2 * time.Hour)

	req := &pb.UpdateScheduledJobRequest{
		JobId:   jobID.String(),
		Payload: string(newPayload),
		RunAt:   timestamppb.New(newRunAt),
		// Assuming other fields like JobType, Priority, Status are not updatable or tested separately
	}

	originalJob := &domain.ScheduledJob{
		ID:      jobID,
		UserID:  uuid.NullUUID{UUID: userID, Valid: true},
		JobType: domain.JobTypeSMS,
		Payload: json.RawMessage(`{"key":"old_value"}`),
		RunAt:   time.Now().Add(1 * time.Hour),
		Status:  domain.StatusQueued,
	}

	t.Run("SuccessfulUpdate", func(t *testing.T) {
		comps.mockRepo.On("GetJob", ctx, jobID).Return(originalJob, nil).Once()
		comps.mockRepo.On("UpdateJob", ctx, mock.MatchedBy(func(job *domain.ScheduledJob) bool {
			return job.ID == jobID &&
				string(job.Payload) == string(newPayload) &&
				job.RunAt.Unix() == newRunAt.Unix() // Compare Unix timestamps for time equality
		})).Return(nil).Once()

		res, err := comps.server.UpdateScheduledJob(ctx, req)

		require.NoError(t, err)
		require.NotNil(t, res)
		assert.Equal(t, jobID.String(), res.JobId)

		comps.mockRepo.AssertExpectations(t)
		comps.mockRepo.ExpectedCalls = nil
	})

	t.Run("UpdateJobNotFound", func(t *testing.T) {
		comps.mockRepo.On("GetJob", ctx, jobID).Return(nil, domain.ErrScheduledJobNotFound).Once()

		res, err := comps.server.UpdateScheduledJob(ctx, req)
		require.Error(t, err)
		st, ok := status.FromError(err)
		require.True(t, ok)
		assert.Equal(t, codes.NotFound, st.Code())
		comps.mockRepo.AssertExpectations(t)
		comps.mockRepo.AssertNotCalled(t, "UpdateJob", mock.Anything, mock.Anything)
		comps.mockRepo.ExpectedCalls = nil
	})

	t.Run("RepositoryErrorOnUpdate", func(t *testing.T) {
		dbError := errors.New("DB update error")
		comps.mockRepo.On("GetJob", ctx, jobID).Return(originalJob, nil).Once()
		comps.mockRepo.On("UpdateJob", ctx, mock.AnythingOfType("*domain.ScheduledJob")).Return(dbError).Once()

		res, err := comps.server.UpdateScheduledJob(ctx, req)
		require.Error(t, err)
		st, ok := status.FromError(err)
		require.True(t, ok)
		assert.Equal(t, codes.Internal, st.Code())
		comps.mockRepo.AssertExpectations(t)
		comps.mockRepo.ExpectedCalls = nil
	})
}


func TestSchedulerServer_DeleteScheduledJob(t *testing.T) {
	comps := setupSchedulerServerTest(t)
	ctx := context.Background()
	jobID := uuid.New()
	req := &pb.DeleteScheduledJobRequest{JobId: jobID.String()}

	t.Run("SuccessfulDelete", func(t *testing.T) {
		comps.mockRepo.On("DeleteJob", ctx, jobID).Return(nil).Once()
		res, err := comps.server.DeleteScheduledJob(ctx, req)
		require.NoError(t, err)
		require.NotNil(t, res) // Should be emptypb.Empty
		assert.Equal(t, &emptypb.Empty{}, res)
		comps.mockRepo.AssertExpectations(t)
		comps.mockRepo.ExpectedCalls = nil
	})

	t.Run("DeleteJobNotFound", func(t *testing.T) {
		comps.mockRepo.On("DeleteJob", ctx, jobID).Return(domain.ErrScheduledJobNotFound).Once()
		res, err := comps.server.DeleteScheduledJob(ctx, req)
		require.Error(t, err)
		st, ok := status.FromError(err)
		require.True(t, ok)
		assert.Equal(t, codes.NotFound, st.Code())
		comps.mockRepo.AssertExpectations(t)
		comps.mockRepo.ExpectedCalls = nil
	})

	t.Run("RepositoryErrorOnDelete", func(t *testing.T) {
		dbError := errors.New("DB delete error")
		comps.mockRepo.On("DeleteJob", ctx, jobID).Return(dbError).Once()
		res, err := comps.server.DeleteScheduledJob(ctx, req)
		require.Error(t, err)
		st, ok := status.FromError(err)
		require.True(t, ok)
		assert.Equal(t, codes.Internal, st.Code())
		comps.mockRepo.AssertExpectations(t)
		comps.mockRepo.ExpectedCalls = nil
	})
}


func TestSchedulerServer_ListScheduledJobs(t *testing.T) {
	comps := setupSchedulerServerTest(t)
	ctx := context.Background()
	userID := uuid.New()

	req := &pb.ListScheduledJobsRequest{
		UserId:   userID.String(),
		Page:     1,
		PageSize: 10,
		JobType:  string(domain.JobTypeSMS),
		Status:   string(domain.StatusQueued),
	}

	t.Run("SuccessfulListWithItems", func(t *testing.T) {
		job1ID := uuid.New()
		mockJobs := []*domain.ScheduledJob{
			{ID: job1ID, UserID: uuid.NullUUID{UUID: userID, Valid: true}, JobType: domain.JobTypeSMS, Status: domain.StatusQueued, Payload: json.RawMessage(`{}`), RunAt: time.Now()},
		}
		comps.mockRepo.On("ListJobs", ctx, uuid.NullUUID{UUID: userID, Valid: true}, domain.JobTypeSMS, domain.StatusQueued, 1, 10).Return(mockJobs, 1, nil).Once()

		res, err := comps.server.ListScheduledJobs(ctx, req)
		require.NoError(t, err)
		require.NotNil(t, res)
		assert.Len(t, res.Jobs, 1)
		assert.Equal(t, int32(1), res.TotalCount)
		assert.Equal(t, job1ID.String(), res.Jobs[0].JobId)
		comps.mockRepo.AssertExpectations(t)
		comps.mockRepo.ExpectedCalls = nil
	})

	t.Run("SuccessfulListEmpty", func(t *testing.T) {
		comps.mockRepo.On("ListJobs", ctx, uuid.NullUUID{UUID: userID, Valid: true}, domain.JobTypeSMS, domain.StatusQueued, 1, 10).Return([]*domain.ScheduledJob{}, 0, nil).Once()
		res, err := comps.server.ListScheduledJobs(ctx, req)
		require.NoError(t, err)
		require.NotNil(t, res)
		assert.Len(t, res.Jobs, 0)
		assert.Equal(t, int32(0), res.TotalCount)
		comps.mockRepo.AssertExpectations(t)
		comps.mockRepo.ExpectedCalls = nil
	})

	t.Run("RepositoryErrorOnList", func(t *testing.T) {
		dbError := errors.New("DB list error")
		comps.mockRepo.On("ListJobs", ctx, uuid.NullUUID{UUID: userID, Valid: true}, domain.JobTypeSMS, domain.StatusQueued, 1, 10).Return(nil, 0, dbError).Once()
		res, err := comps.server.ListScheduledJobs(ctx, req)
		require.Error(t, err)
		st, ok := status.FromError(err)
		require.True(t, ok)
		assert.Equal(t, codes.Internal, st.Code())
		comps.mockRepo.AssertExpectations(t)
		comps.mockRepo.ExpectedCalls = nil
	})

	t.Run("ListWithOptionalUserID", func(t *testing.T) {
		listReqNoUser := &pb.ListScheduledJobsRequest{Page: 1, PageSize: 5} // No UserID
		comps.mockRepo.On("ListJobs", ctx, uuid.NullUUID{Valid: false}, domain.JobType(""), domain.JobStatus(""), 1, 5).Return([]*domain.ScheduledJob{}, 0, nil).Once()
		_, err := comps.server.ListScheduledJobs(ctx, listReqNoUser)
		require.NoError(t, err)
		comps.mockRepo.AssertExpectations(t)
		comps.mockRepo.ExpectedCalls = nil
	})
}

// Note: The domain.ScheduledJobRepository interface used in job_poller_test.go has different method signatures
// (e.g., CreateJob returns only error, UpdateStatus has different params) than what might be expected
// for a full CRUD gRPC service. This test file assumes the repository interface matches the needs of these gRPC handlers.
// If the actual domain.ScheduledJobRepository differs significantly (e.g. CreateJob should return the created job for the gRPC response),
// then the mock and potentially the gRPC handlers' interaction with it would need adjustment.
// For this test, the mocks are based on the assumed gRPC handler interactions.
// The ListJobs mock was updated to match a more typical signature: (ctx, userID, jobType, status, page, pageSize).
// The AcquireDueJobs, UpdateStatus (specific to poller), MarkForRetry are not directly tested here as they are not directly called by these gRPC handlers.
// They are included in the mock for interface completeness if the same mock were used elsewhere.
// The CreateJob mock currently returns only error. The gRPC handler CreateScheduledJob generates the JobId itself and returns it.
// This means the CreateJob repo method doesn't need to return the full job object.
// This seems consistent with current mock.
// The UpdateJob mock in repo: `UpdateJob(ctx context.Context, job *domain.ScheduledJob) error`
// The gRPC handler for UpdateScheduledJob:
// 1. Calls repo.GetJob to fetch current job.
// 2. Modifies fields.
// 3. Calls repo.UpdateJob with the modified job.
// This is tested.
```
